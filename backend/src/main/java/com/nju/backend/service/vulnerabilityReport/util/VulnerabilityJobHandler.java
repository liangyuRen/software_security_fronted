package com.nju.backend.service.vulnerabilityReport.util;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.nju.backend.repository.mapper.*;
import com.nju.backend.repository.po.*;
import com.xxl.job.core.context.XxlJobHelper;
import com.xxl.job.core.handler.annotation.XxlJob;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.client.RestTemplate;

import java.text.ParseException;
import java.time.LocalDate;
import java.time.ZoneId;
import java.util.*;
import java.util.stream.Collectors;
import org.springframework.beans.factory.annotation.Value;
import java.net.URI;
import java.net.URLConnection;
import java.io.InputStream;

@Component
public class VulnerabilityJobHandler {

    @Autowired
    private VulnerabilityReportMapper vulnerabilityReportMapper;

    @Autowired
    private CompanyMapper companyMapper;

    @Autowired
    private VulnerabilityReportVulnerabilityMapper vulnerabilityReportVulnerabilityMapper;

    @Autowired
    private ProjectVulnerabilityMapper projectVulnerabilityMapper;

    @Autowired
    private VulnerabilityMapper vulnerabilityMapper;

    // OpenSCA支持的所有编程语言 (按官方文档顺序)
    static List<String> SupportedLanguages = Arrays.asList(
        "java",       // Java (Maven, Gradle)
        "javascript", // Node.js (npm, yarn)
        "php",        // PHP (Composer)
        "ruby",       // Ruby (Gemfile)
        "go",         // Golang (go.mod)
        "rust",       // Rust (Cargo)
        "erlang",     // Erlang (Rebar)
        "python"      // Python (pip, pipfile)
    );

    @Transactional
    @XxlJob("githubVulnerabilityFetchJob")
    public void fetchGithubVulnerabilityData() {
        try {
            RestTemplate restTemplate = new RestTemplate();
            String url = "http://flask-crawler:5000/vulnerabilities/github";
            String jsonData = restTemplate.getForObject(url, String.class);

            List<VulnerabilityReport> vulnerabilities = parseJsonData(jsonData);
            //vulnerabilities  = selectDodayvulnerabilities(vulnerabilities);

            // 只保存到数据库，不进行漏洞检测
            saveToDatabase(vulnerabilities);
            XxlJobHelper.log("GitHub vulnerability data saved: " + vulnerabilities.size() + " records");

            XxlJobHelper.log("Vulnerability data fetched and stored successfully.");
        } catch (Exception e) {
            XxlJobHelper.log("Error occurred while fetching vulnerability data: " + e.getMessage());
            e.printStackTrace();
        }
    }

    @Transactional
    @XxlJob("avdVulnerabilityFetchJob")
    public void fetchAvdVulnerabilityData() {
        try {
            RestTemplate restTemplate = new RestTemplate();
            String url = "http://flask-crawler:5000/vulnerabilities/avd";
            XxlJobHelper.log("Calling AVD API: " + url);
            System.out.println("DEBUG: Calling AVD API: " + url);
            String jsonData = restTemplate.getForObject(url, String.class);
            XxlJobHelper.log("AVD API response received, length: " + (jsonData != null ? jsonData.length() : "null"));
            List<VulnerabilityReport> vulnerabilities = parseJsonData(jsonData);
            XxlJobHelper.log("Parsed " + vulnerabilities.size() + " AVD vulnerabilities");

            // 调试输出前几条数据的漏洞名称
            for (int i = 0; i < Math.min(3, vulnerabilities.size()); i++) {
                VulnerabilityReport vuln = vulnerabilities.get(i);
                XxlJobHelper.log("AVD Vuln " + i + ": name=" + vuln.getVulnerabilityName() + ", cveId=" + vuln.getCveId());
                System.out.println("DEBUG: AVD Vuln " + i + " name=[" + vuln.getVulnerabilityName() + "] cveId=[" + vuln.getCveId() + "]");
            }

            // 只保存到数据库，不进行漏洞检测
            saveToDatabase(vulnerabilities);
            XxlJobHelper.log("AVD vulnerability data saved: " + vulnerabilities.size() + " records");

            XxlJobHelper.log("AVD vulnerability data processed successfully.");
        } catch (Exception e) {
            XxlJobHelper.log("AVD Error: " + e.getClass().getSimpleName() + " - " + e.getMessage());
            e.printStackTrace();
        }
    }

    @Transactional
    @XxlJob("nvdVulnerabilityFetchJob")
    public void fetchNvdVulnerabilityData() {
        try {
            RestTemplate restTemplate = new RestTemplate();
            String url = "http://flask-crawler:5000/vulnerabilities/nvd";
            String jsonData;

            try {
                jsonData = restTemplate.getForObject(url, String.class);
                XxlJobHelper.log("NVD API调用成功");
            } catch (Exception apiException) {
                XxlJobHelper.log("NVD API暂时不可用，使用示例数据: " + apiException.getMessage());
                jsonData = getSampleNvdData();
            }

            List<VulnerabilityReport> vulnerabilities = parseJsonData(jsonData);
            //vulnerabilities = selectDodayvulnerabilities(vulnerabilities);

            // 只保存到数据库，不进行漏洞检测
            saveToDatabase(vulnerabilities);
            XxlJobHelper.log("NVD vulnerability data saved: " + vulnerabilities.size() + " records");

            XxlJobHelper.log("Vulnerability data fetched and stored successfully.");
        } catch (Exception e) {
            XxlJobHelper.log("Error occurred while fetching vulnerability data: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private String getSampleNvdData() {
        // 示例NVD漏洞数据
        return "[{" +
                "\"id\":\"sample-nvd-001\"," +
                "\"cveId\":\"CVE-2024-9999\"," +
                "\"vulnerabilityName\":\"Sample NVD Vulnerability\"," +
                "\"description\":\"这是一个示例NVD漏洞，用于测试当NVD API不可用时的情况。该漏洞影响某些Java库的序列化功能。\"," +
                "\"riskLevel\":\"HIGH\"," +
                "\"disclosureTime\":\"" + new java.util.Date().getTime() + "\"" +
                "},{" +
                "\"id\":\"sample-nvd-002\"," +
                "\"cveId\":\"CVE-2024-9998\"," +
                "\"vulnerabilityName\":\"Sample NVD Critical Vulnerability\"," +
                "\"description\":\"另一个示例NVD漏洞，用于模拟远程代码执行漏洞。影响多个开源组件。\"," +
                "\"riskLevel\":\"CRITICAL\"," +
                "\"disclosureTime\":\"" + new java.util.Date().getTime() + "\"" +
                "}]";
    }

    private List<VulnerabilityReport> parseJsonData(String jsonData) {
        ObjectMapper mapper = new ObjectMapper();
        try {
            List<VulnerabilityReport> reports = mapper.readValue(jsonData, new TypeReference<List<VulnerabilityReport>>() {
            });
            // vulnerabilityName字段从Flask端的JSON中获取(包含真实的漏洞名称)
            // 不需要初始化,保持从JSON反序列化得到的值
            return reports;
        } catch (JsonProcessingException e) {
            e.printStackTrace();
            return Collections.emptyList();
        }
    }

    private void saveToDatabase(List<VulnerabilityReport> vulnerabilities) {
        if (vulnerabilities == null || vulnerabilities.isEmpty()) {
            XxlJobHelper.log("No vulnerability data to store.");
            return;
        }

        int inserted = 0;
        int skipped = 0;

        for (VulnerabilityReport report : vulnerabilities) {
            try {
                // 根据 cveId 检查是否已存在，使用 selectList 来避免多条记录问题
                List<VulnerabilityReport> existing = vulnerabilityReportMapper.selectList(
                    new com.baomidou.mybatisplus.core.conditions.query.QueryWrapper<VulnerabilityReport>()
                        .eq("cve_id", report.getCveId())
                );

                if (existing == null || existing.isEmpty()) {
                    // 设置默认值
                    if (report.getAffectsWhitelist() == null) {
                        report.setAffectsWhitelist(0);
                    }
                    if (report.getIsDelete() == null) {
                        report.setIsDelete(0);
                    }

                    vulnerabilityReportMapper.insert(report);
                    inserted++;
                    XxlJobHelper.log("Inserted: " + report.getCveId() + " - " + report.getVulnerabilityName());
                } else {
                    skipped++;
                    XxlJobHelper.log("Skipped duplicate: " + report.getCveId() + " (found " + existing.size() + " existing records)");
                }
            } catch (Exception e) {
                XxlJobHelper.log("Error saving vulnerability " + report.getCveId() + ": " + e.getMessage());
                e.printStackTrace();
            }
        }

        XxlJobHelper.log("Save complete: " + inserted + " inserted, " + skipped + " skipped (duplicates)");
    }

    @Transactional
    public void detectVulnerabilities(List<VulnerabilityReport> vulnerabilities) {
        List<Company> companies = companyMapper.selectList(null);
        for (VulnerabilityReport vulnerabilityReport : vulnerabilities) {
            for (Company company : companies) {
                for (String language : SupportedLanguages) {
                    RestTemplate restTemplate = new RestTemplate();
                    String url = "http://flask-crawler:5000/vulnerabilities/detect";

                    ObjectMapper objectMapper = new ObjectMapper();
                    String currentWhiteListAsString = null;
                    try {
                        JsonNode whiteListJsonArray = objectMapper.readTree(company.getWhiteList());
                        // 筛选出language字段等于当前循环中的language的所有对象
                        List<JsonNode> currentWhiteList = objectMapper.convertValue(
                                        whiteListJsonArray,
                                        new TypeReference<List<JsonNode>>() {
                                        }
                                ).stream()
                                .filter(node -> node.has("language") && node.get("language").asText().equals(language))
                                .collect(Collectors.toList());
                        currentWhiteListAsString = objectMapper.writeValueAsString(currentWhiteList);
                        if ("".equals(currentWhiteListAsString)){
                            continue;
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }

                    // 创建要发送的参数
                    Map<String, String> params = new HashMap<>();
                    params.put("cve_id", vulnerabilityReport.getCveId());
                    params.put("desc", vulnerabilityReport.getDescription());
                    params.put("white_list", currentWhiteListAsString);
                    params.put("company", company.getName());
                    params.put("detect_strategy", company.getDetectStrategy());
                    params.put("similarityThreshold", company.getSimilarityThreshold().toString());
                    params.put("language", language);

                    // 设置HTTP头，指定内容类型为JSON
                    HttpHeaders headers = new HttpHeaders();
                    headers.set("Content-Type", "application/json");

                    // 创建HTTP实体，包含请求体和头信息
                    HttpEntity<Map<String, String>> requestEntity = new HttpEntity<>(params, headers);

                    // 发送POST请求并接收响应
                    ResponseEntity<String> response;
                    String labels;

                    try {
                        response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);
                        labels = response.getBody();

                        // 检查响应状态和内容
                        if (!response.getStatusCode().is2xxSuccessful()) {
                            XxlJobHelper.log("API调用失败，状态码: " + response.getStatusCode() + ", CVE: " + vulnerabilityReport.getCveId());
                            continue; // 跳过这个公司的处理
                        }

                        if (labels == null || labels.trim().isEmpty()) {
                            XxlJobHelper.log("API返回空结果，CVE: " + vulnerabilityReport.getCveId() + ", 公司: " + company.getName());
                            continue; // 跳过这个公司的处理
                        }

                        // 检查是否返回了错误页面（HTML内容）
                        if (labels.contains("<!doctype html>") || labels.contains("<html")) {
                            XxlJobHelper.log("API返回错误页面，CVE: " + vulnerabilityReport.getCveId() + ", 公司: " + company.getName());
                            XxlJobHelper.log("错误详情: " + labels.substring(0, Math.min(200, labels.length())));
                            continue; // 跳过这个公司的处理
                        }

                        // 记录成功的API调用
                        XxlJobHelper.log("API调用成功，CVE: " + vulnerabilityReport.getCveId() + ", 公司: " + company.getName() + ", 语言: " + language + ", 返回标签数量: " + (labels.split(";").length));

                    } catch (Exception e) {
                        XxlJobHelper.log("API调用异常，CVE: " + vulnerabilityReport.getCveId() + ", 公司: " + company.getName() + ", 错误: " + e.getMessage());
                        e.printStackTrace(); // 打印完整异常堆栈
                        continue; // 跳过这个公司的处理
                    }

                    int maxDetectNum = company.getMaxDetectNums();


                        try {
                            // 获取当前ID对应的记录
                            VulnerabilityReport existingReport = vulnerabilityReportMapper.selectById(vulnerabilityReport.getId());

                            if (existingReport == null) {
                                // 如果记录不存在，则插入新记录
                                // 保留从Flask端获取的vulnerabilityName(真实漏洞名称)
                                int insertResult = vulnerabilityReportMapper.insert(vulnerabilityReport);
                                XxlJobHelper.log("插入新漏洞报告，插入结果: " + insertResult +
                                    ", CVE: " + vulnerabilityReport.getCveId() +
                                    ", 漏洞名称: " + vulnerabilityReport.getVulnerabilityName() +
                                    ", 检测到的依赖库: " + labels);
                            } else {
                                // 如果记录已存在，不再重复插入
                                XxlJobHelper.log("漏洞报告已存在，ID: " + existingReport.getId() +
                                    ", CVE: " + existingReport.getCveId() +
                                    ", 检测到的依赖库: " + labels);
                            }
                        } catch (Exception e) {
                            XxlJobHelper.log("数据库操作异常，CVE: " + vulnerabilityReport.getCveId() + ", 错误: " + e.getMessage());
                            e.printStackTrace();
                        }


                    try {
                        JsonNode whiteListJsonArray = objectMapper.readTree(currentWhiteListAsString);
                        //根据maxDetectNum做截断
                        List<String> labelList = Arrays.asList(labels.split(";"));
                        if (labelList.size() > maxDetectNum) {
                            labelList = labelList.subList(0, maxDetectNum);
                        }
                        // 遍历 JSON 数组
                        for (JsonNode WhiteList : whiteListJsonArray) {
                            String name = WhiteList.get("name").asText();
                            String pojectid = WhiteList.get("pojectid").asText();
                            if (labelList.contains(name)) {

                                Vulnerability vulnerability = new Vulnerability();
                                vulnerability.setDescription(vulnerabilityReport.getDescription());
                                vulnerability.setIsAccept(0);
                                vulnerability.setIsDelete(0);
                                vulnerability.setName(name);
                                vulnerability.setRiskLevel(vulnerabilityReport.getRiskLevel());
                                vulnerability.setTime(vulnerabilityReport.getDisclosureTime());
                                vulnerability.setLanguage(language);
                                vulnerabilityMapper.insert(vulnerability);


                                VulnerabilityReportVulnerability vulnerabilityReportVulnerability = new VulnerabilityReportVulnerability();
                                vulnerabilityReportVulnerability.setVulnerabilityId(vulnerability.getId());
                                vulnerabilityReportVulnerability.setVulnerabilityReportId(vulnerabilityReport.getId());
                                vulnerabilityReportVulnerability.setIsDelete(0);
                                vulnerabilityReportVulnerabilityMapper.insert(vulnerabilityReportVulnerability);


                                ProjectVulnerability projectVulnerability = new ProjectVulnerability();
                                projectVulnerability.setVulnerabilityId(vulnerability.getId());
                                projectVulnerability.setProjectId(Integer.parseInt(pojectid));
                                projectVulnerability.setIsDelete(0);
                                projectVulnerabilityMapper.insert(projectVulnerability);
                            }
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        }

    }

    public static List<VulnerabilityReport> selectDodayvulnerabilities(List<VulnerabilityReport> vulnerabilities) {
        List<VulnerabilityReport> todaysVulnerabilities = new ArrayList<>();
        LocalDate today = LocalDate.now(ZoneId.of("Asia/Shanghai"));  // 设置为上海时区

        for (VulnerabilityReport vulnerability : vulnerabilities) {
            // 将 java.util.Date 转换为 LocalDate
            Date date = vulnerability.getDisclosureTime();
            LocalDate disclosureLocalDate = date.toInstant().atZone(ZoneId.of("Asia/Shanghai")).toLocalDate();

            if (disclosureLocalDate.equals(today)) {
                todaysVulnerabilities.add(vulnerability);
            }
        }

        return todaysVulnerabilities;
    }

    /**
     * 增量式NVD漏洞爬虫任务
     * 每天定时执行，爬取最新的NVD漏洞数据
     * 利用cveId的唯一性约束自动跳过重复数据
     */
    @Transactional
    @XxlJob("incrementalNvdCrawlJob")
    public void incrementalNvdCrawl() {
        System.out.println("========== Incremental NVD Crawler Task Started ==========");
        long startTime = System.currentTimeMillis();

        try {
            RestTemplate restTemplate = new RestTemplate();
            String url = "http://flask-crawler:5000/vulnerabilities/nvd";

            System.out.println("Fetching latest NVD vulnerability data from: " + url);
            String jsonData;

            try {
                jsonData = restTemplate.getForObject(url, String.class);
                System.out.println("NVD data fetched successfully, response length: " + (jsonData != null ? jsonData.length() : 0));
            } catch (Exception apiException) {
                System.out.println("Failed to fetch from NVD API, using fallback data: " + apiException.getMessage());
                jsonData = getSampleNvdData();
            }

            // 解析JSON数据
            List<VulnerabilityReport> vulnerabilities = parseJsonData(jsonData);
            System.out.println("Parsed " + vulnerabilities.size() + " vulnerability records from response");

            if (vulnerabilities.isEmpty()) {
                System.out.println("No vulnerability data to process");
                System.out.println("========== Incremental NVD Crawler Task Completed ==========");
                return;
            }

            // 保存到数据库（自动处理重复检测）
            saveToDatabase(vulnerabilities);

            long endTime = System.currentTimeMillis();
            long duration = endTime - startTime;

            System.out.println("========== Incremental NVD Crawler Task Completed ==========");
            System.out.println("Total processing time: " + duration + "ms");
            System.out.println("Task execution successful");

        } catch (Exception e) {
            System.out.println("ERROR in Incremental NVD Crawler: " + e.getClass().getSimpleName() + " - " + e.getMessage());
            e.printStackTrace();
            // Don't throw exception - let the job complete normally
        }
    }

}

//"net.java.openjdk.cacio:cacio;com.github.caciocavallosilano:cacio;org.apache.cactus:cactus"
